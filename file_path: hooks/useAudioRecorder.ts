import { useState, useRef, useCallback, useEffect } from 'react'; import { Platform } from 'react-native'; import { Audio, InterruptionModeIOS, InterruptionModeAndroid } from 'expo-av';  interface UseAudioRecorderReturn {   isRecording: boolean;   isListening: boolean;   soundLevel: number;   recordingDuration: number;   startListening: () => Promise<void>;   stopListening: () => Promise<void>;   startRecording: () => Promise<void>;   stopRecording: () => Promise<string | null>;   hasPermission: boolean;   requestPermission: () => Promise<boolean>;   sensitivity: number;   setSensitivity: (value: number) => void; }  export function useAudioRecorder(): UseAudioRecorderReturn {   const [isRecording, setIsRecording] = useState(false);   const [isListening, setIsListening] = useState(false);   const [soundLevel, setSoundLevel] = useState(0);   const [recordingDuration, setRecordingDuration] = useState(0);   const [hasPermission, setHasPermission] = useState(false);   const [sensitivity, setSensitivity] = useState(0.35);      const recordingRef = useRef<Audio.Recording | null>(null);   const meteringIntervalRef = useRef<ReturnType<typeof setInterval> | null>(null);   const durationIntervalRef = useRef<ReturnType<typeof setInterval> | null>(null);    const configureAudioMode = useCallback(async (forRecording: boolean) => {     try {       await Audio.setAudioModeAsync({         allowsRecordingIOS: forRecording,         playsInSilentModeIOS: true,         staysActiveInBackground: true,         interruptionModeIOS: InterruptionModeIOS.MixWithOthers,         interruptionModeAndroid: InterruptionModeAndroid.DoNotMix,         shouldDuckAndroid: false,         playThroughEarpieceAndroid: false,       });     } catch (error) {       console.error('[useAudioRecorder] Audio mode error:', error);     }   }, []);    const requestPermission = useCallback(async () => {     try {       const { status } = await Audio.requestPermissionsAsync();       const granted = status === 'granted';       setHasPermission(granted);       if (granted) await configureAudioMode(true);       return granted;     } catch (error) {       console.error('[useAudioRecorder] Permission error:', error);       return false;     }   }, [configureAudioMode]);    useEffect(() => {     Audio.getPermissionsAsync().then((result) => {       if (result?.status === 'granted') setHasPermission(true);     }).catch(() => {});          return () => {       if (meteringIntervalRef.current) clearInterval(meteringIntervalRef.current);       if (durationIntervalRef.current) clearInterval(durationIntervalRef.current);     };   }, []);    const startListening = useCallback(async () => {     try {       await configureAudioMode(true);       const { recording } = await Audio.Recording.createAsync(         Audio.RecordingOptionsPresets.HIGH_QUALITY,         (status) => {           if (status.isRecording && status.metering !== undefined) {             const normalized = Math.max(0, (status.metering + 60) / 60);             setSoundLevel(normalized);           }         },         100       );       recordingRef.current = recording;       setIsListening(true);     } catch (error) {       console.error('[useAudioRecorder] Start listening error:', error);     }   }, [configureAudioMode]);    const stopListening = useCallback(async () => {     if (recordingRef.current) {       try {         await recordingRef.current.stopAndUnloadAsync();       } catch (error) {         console.log('[useAudioRecorder] Stop listening cleanup:', error);       }       recordingRef.current = null;     }     setIsListening(false);     setSoundLevel(0);   }, []);    const startRecording = useCallback(async () => {     try {       if (recordingRef.current) await stopListening();       await configureAudioMode(true);        const { recording } = await Audio.Recording.createAsync(         Audio.RecordingOptionsPresets.HIGH_QUALITY,         (status) => {           if (status.isRecording) {             setRecordingDuration(status.durationMillis);             if (status.metering !== undefined) {               const normalized = Math.max(0, (status.metering + 60) / 60);               setSoundLevel(normalized);             }           }         },         100       );              recordingRef.current = recording;       setIsRecording(true);       setRecordingDuration(0);     } catch (error) {       console.error('[useAudioRecorder] Start recording error:', error);     }   }, [configureAudioMode, stopListening]);    const stopRecording = useCallback(async (): Promise<string | null> => {     if (!recordingRef.current) return null;     try {       await recordingRef.current.stopAndUnloadAsync();       const uri = recordingRef.current.getURI();       recordingRef.current = null;       setIsRecording(false);       setSoundLevel(0);       return uri;     } catch (error) {       console.error('[useAudioRecorder] Stop recording error:', error);       setIsRecording(false);       return null;     }   }, []);    return {     isRecording, isListening, soundLevel, recordingDuration,     startListening, stopListening, startRecording, stopRecording,     hasPermission, requestPermission, sensitivity, setSensitivity,   }; }
